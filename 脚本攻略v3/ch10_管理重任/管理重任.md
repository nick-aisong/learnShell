任重管理
========
| 目录                         | 主要命令       |
| ---------------------------- | -------------- |
| 收集进程信息                 | top、ps、pgrep |
| which、whereis、whatis与file |                |
| 杀死进程以及发送和响应信号   |                |
| 向用户终端发送消息           |                |
| /proc文件系统                |                |
| 收集系统信息                 |                |
| 使用cron进行调度             |                |
| 数据库的形式及用法           |                |
| 读写SQLite数据库             |                |
| 读写MySQL数据库              |                |
| 用户管理脚本                 |                |
| 图像文件的批量缩放及格式转换 |                |
| 终端截图                     |                |
| 集中管理多个终端             |                |

#### 收集进程信息

进程是程序的运行实例（running instance）。运行在计算机中的多个进程都被分配了一个称为
进程ID（PID）的唯一标识数字。同一个程序的多个实例可以同时运行，但是它们各自拥有不同
PID和属性。进程属性包括拥有该进程的用户、进程使用的内存数量、进程占用的CPU时间等

和进程管理相关的重要命令是top、ps和pgrep



ps可以报告活跃进程的相关信息。这些信息包括：拥有进程的用户、进程的起始时间、进程
对应的命令路径、PID、进程所属的终端（TTY）、进程使用的内存、进程占用的CPU等

```shell
$ ps
 PID TTY TIME CMD
 1220 pts/0 00:00:00 bash
 1242 pts/0 00:00:00 ps 
 
 # ps命令默认只显示从当前终端所启动的进程
 # 第一列是PID，第二列是TTY，第三列是进程的运行时长，最后一列是CMD（进程所对应的命令）
 
 
 # 可以使用命令行参数来修改ps命令的输出
 # 选项-f（full）可以显示多列信息
 $ ps -f
UID PID PPID C STIME TTY TIME CMD
slynux 1220 1219 0 18:18 pts/0 00:00:00 -bash
slynux 1587 1220 0 18:59 pts/0 00:00:00 ps -f 
 
 # 选项-e（every）和-ax（all）能够输出系统中运行的所有进程信息
 # 选项-x（配合-a）可以解除ps默认设置的TTY限制
 # 通常如果使用不带参数的ps命令，只能打印出属于当前终端的进程
 
 # 命令ps -e、ps -ef、ps -ax以及ps -axf都能够生成包含所有进程的报告，提供比ps更多的信息
$ ps -e | head -5
PID TTY TIME CMD
1 ? 00:00:00 init
2 ? 00:00:00 kthreadd
3 ? 00:00:00 migration/0
4 ? 00:00:00 ksoftirqd/0 

# 选项-o PARAMETER1,PARAMETER2可以指定显示哪些数据

# -o的参数以逗号（,）作为分隔符
# 逗号与接下来的参数之间是没有空格的
# 选项-o可以和选项-e配合使用（-oe）来列出系统中运行的所有进程
# 但如果在-o中需要使用过滤器，例如列出特定用户拥有的进程，那就不能再搭配-e了
# 因为-e和过滤器结合使用没有任何实际效果，依旧会显示所有的进程

# 在下面的例子中，comm代表COMMAND，pcpu代表CPU占用率
$ ps -eo comm,pcpu | head -5
COMMAND %CPU
init 0.0
kthreadd 0.0
migration/0 0.0
ksoftirqd/0 0.0
```

选项-o可以使用不同的参数

| 参 数 | 描 述                |
| :---- | :------------------- |
| pcpu  | CPU占用率            |
| pid   | 进程ID               |
| ppid  | 父进程ID             |
| pmem  | 内存使用率           |
| comm  | 可执行文件名         |
| cmd   | 简单命令             |
| user  | 启动进程的用户       |
| nice  | 优先级               |
| time  | 累计的CPU时间        |
| etime | 进程启动后运行的时长 |
| tty   | 所关联的TTY设备      |
| euid  | 有效用户ID           |
| stat  | 进程状态             |

补充内容

1. 显示进程的环境变量

```shell
# 有些进程依赖于所定义的环境变量。了解这些环境变量及其取值有助于调试或定制进程
# ps命令通常并不会显示进程的环境信息。输出修饰符e可以将其添加到命令尾部
$ ps e

$ ps -eo pid,cmd e | tail -n 1
1238 -bash USER=slynux LOGNAME=slynux HOME=/home/slynux
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
MAIL=/var/mail/slynux SHELL=/bin/bash SSH_CLIENT=10.211.55.2 49277 22
SSH_CONNECTION=10.211.55.2 49277 10.211.55.4 22 SSH_TTY=/dev/pts/0 

# 当使用如cron这类调度工具运行应用程序时，有可能忘了设置所需的环境变量
# 下面的crontab条目就无法打开基于GUI窗口的应用
00 10 * * * /usr/bin/windowapp 

# 因为GUI应用需要使用环境变量DISPLAY
# 要想确定都需要哪些环境变量，可以先手动运行windowapp，然后使用命令ps -C windowapp -eo cmd e
# 确定了所需的环境变量之后，将其定义在crontab中的命令之前
00 10 * * * DISPLAY=:0 /usr/bin/windowapp
# 或者
DISPLAY=:0
00 10 * * * /usr/bin/windowapp 
# 环境变量定义DISPLAY=:0是从ps命令的输出中得到的
```

2. 创建进程树状视图

```shell
# ps命令能够输出进程的PID，但是从子进程一直跟踪到最终的父进程是一件非常枯燥的事
# 在ps命令的尾部加上f就可以创建进程的树状视图，显示出任务之间的父子关系
# 下面的例子展示了bash shell所调用的ssh会话，前者运行在xterm中
$ ps -u clif f | grep -A2 xterm | head -3
15281 ? S 0:00 xterm
15284 pts/20 Ss+ 0:00 \_ bash
15286 pts/20 S+ 0:18 \_ ssh 192.168.1.2 
```

3. 对ps输出进行排序

```shell
# ps命令的输出默认是没有经过排序的
# 选项--sort可以强制ps对输出排序。参数前的+表示升序，-表示降序
$ ps [OPTIONS] --sort -paramter1,+parameter2,parameter3.. 

# 列出占用CPU最多的前5个进程
$ ps -eo comm,pcpu --sort -pcpu | head -5
COMMAND %CPU
Xorg 0.1
hald-addon-stor 0.0
ata/0 0.0
scsi_eh_0 0.0 

# grep可以过滤ps的输出。要想找出当前运行的所有Bash进程，可以使用
$ ps -eo comm,pid,pcpu,pmem | grep bash
bash 1255 0.0 0.3
bash 1680 5.5 0.3 
```

4. 根据真实用户/ID以及有效用户/ID过滤ps输出

ps命令可以根据指定的真实/有效用户名或ID（real and effective username or ID）对进程进行
分组。通过检查每一条输出是否属于参数列表中指定的有效用户或真实用户，ps就能够过滤输出

- 使用-u EUSER1,EUSER2 …指定有效用户列表
- 使用-U RUSER1,RUSER2 …指定真实用户列表

```shell
# 显示以root作为有效用户ID和真实用户ID的用户以及CPU占用率
$ ps -u root -U root -o user,pcpu 

# -o可以和-e结合成-eo的形式，但如果使用了过滤器，就不能再使用-e了，它会使过滤器选项失效
```

5. 用TTY过滤ps输出

```shell
# 选项-t可以指定TTY列表
$ ps -t TTY1, TTY2 .. 

$ ps -t pts/0,pts/1
 PID TTY TIME CMD
 1238 pts/0 00:00:00 bash
 1835 pts/1 00:00:00 bash
 1864 pts/0 00:00:00 ps 
```

6. 进程线程的相关信息

```shell
# 选项-L可以显示出线程的相关信息
# 该选项会在输出中添加一列LWP
# 如果再加上选项-f（-LF），就会多显示出两列：NLWP（线程数量）和LWP（线程ID）
$ ps -Lf
UID PID PPID LWP C NLWP STIME TTY TIME CMD
user 1611 1 1612 0 2 Jan16 ? 00:00:00 /usr/lib/gvfs/gvfsd 

# 下面的命令可以列出线程数最多的5个进程
$ ps -eLf --sort -nlwp | head -5
UID PID PPID LWP C NLWP STIME TTY TIME CMD
root 647 1 647 0 64 14:39 ? 00:00:00 /usr/sbin/console-kit-daemon --no-daemon
root 647 1 654 0 64 14:39 ? 00:00:00 /usr/sbin/console-kit-daemon --no-daemon
root 647 1 656 0 64 14:39 ? 00:00:00 /usr/sbin/console-kit-daemon --no-daemon
root 647 1 657 0 64 14:39 ? 00:00:00 /usr/sbin/console-kit-daemon --no-daemon 
```

7. 指定输出宽度以及所要显示的列

ps命令包含多种可用于选择输出字段的选项

| 选项        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| -f          | 显示完整格式，包括父进程的起始时间                           |
| -u userList | 选择userList中的用户所拥有的进程。默认情况下，ps只针对当前用户 |
| -l          | 长格式列表。显示用户ID、父进程PID、占用内存大小等内容        |

8. 找出特定命令对应的进程ID 

```shell
# 假设某个命令有多个实例正在运行
# 在这种情况下，我们需要识别出这些进程的PID
# ps和pgrep命令可以完成这项任务
$ ps -C COMMAND_NAME
# 或者
$ ps -C COMMAND_NAME -o pid= 
# 如果在pid后面加上=，这会去掉ps输出中PID一列的列名
# 要想移除某一列的列名，只需要把=放在对应参数的后面就行了

# 下面的命令可以列出bash进程的PID
$ ps -C bash -o pid=
 1255
 1680 

# pgrep命令也可以列出命令的进程ID列表
$ pgrep bash
1255
1680 

# pgrep只需要使用命令名的一部分作为参数，例如pgrep ash或pgrep bas都没问题
# 但是ps需要你输入准确的命令名
# pgrep也支持输出过滤选项

# 如果不使用换行符作为分隔符，那么可以使用选项-d来指定其他的输出分隔符
$ pgrep COMMAND -d DELIMITER_STRING

$ pgrep bash -d ":"
1255:1680

# 选项-u可以过滤用户
$ pgrep -u root,slynux COMMAND

# 选项-c可以返回匹配的进程数量
$ pgrep -c COMMAN
```

9. 确定系统繁忙程度

系统要么是处于空闲状态，要么是处于过载状态。load average的值描述了系统的负载情
况。它指明了系统中可运行进程的平均数量

uptime和top命令都可以显示平均负载。平均负载由3个值来指定，第1个值指明了1分钟内
的平均值，第2个值指明了5分钟内的平均值，第3个值指明了15分钟内的平均值

```shell
# uptime命令的输出为
$ uptime
12:40:53 up 6:16, 2 users, load average: 0.00, 0.00, 0.00 
```

10. top命令

默认情况下，top命令会列出CPU占用最高的进程列表以及基本的系统统计信息，其中包括
总的任务数、CPU核心数以及内存占用情况。命令输出每隔几秒钟就会更新一次

```shell
# 下面的命令显示出了一些系统统计信息以及CPU占用率最高的进程
$ top
top - 18:37:50 up 16 days, 4:41,7 users,load average 0.08 0.05 .11
Tasks: 395 total, 2 running, 393 sleeping, 0 stopped 0 zombie 
```

#### which、whereis、whatis与file

有些文件可能会出现重名。因此，应该弄清楚被调用的是哪个可执行文件以及一个文件是编
译过的二进制代码还是脚本

which、whereis、file与whatis命令可以给出文件和目录的相关信息

- which

  which命令用来找出某个命令的位置

  ```shell
  $ which ls
  /bin/ls 
  
  # 我们通常在使用命令时，无需知道可执行文件所在的位置
  # 根据对PATH变量的定义，你可以直接使用/bin、/usr/local/bin或/opt/PACKAGENAME/bin目录下的命令
  
  # 当输入命令时，终端会在一组目录中搜索并执行所找到的第一个可执行文件。这些目录由环境变量PATH指定
  $ echo $PATH
  /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin 
  
  # 我们可以添加搜索目录并导出新的PATH
  # 如果要将/opt/bin添加到PATH中，可以使用以下命令
  $ export PATH=$PATH:/opt/bin
  # 将/opt/bin添加到PATH中
  ```

  

- whereis

  whereis与which命令类似，它不仅会返回命令的路径，还能够打印出其对应的命令手册
  以及源代码的路径（如果有的话）

  ```shell
  $ whereis ls
  ls: /bin/ls /usr/share/man/man1/ls.1.gz 
  ```

- whatis

  whatis会输出指定命令的一行简短描述。这些信息是从命令手册中解析得来的

  ```shell
  $ whatis ls
  ls (1) - list directory contents 
  ```

- file

  file命令可以用来确定文件的类型，其语法如下

  ```shell
  $ file FILENAME
  # 该命令返回的文件类型可能是几个单词也可能是一大段描述
  
  $ file /etc/passwd
  /etc/passwd: ASCII text
  
  $ file /bin/ls
  /bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1
  (SYSV), dynamically linked (uses shared libs), for GNU/Linux
  2.6.15, stripped 
  ```

- apropos

  有时候我们需要搜索与某个主题相关的命令。apropos可以搜索包含指定关键字的手册页

  ```shell
  apropos topic
  ```

#### 杀死进程以及发送和响应信号

如果需要降低系统负载或是重启系统（如果进程行为失常，开始耗费过多资源），就得杀死
进程。作为一种进程间通信机制，信号可以中断进程运行并强迫进程执行某些操作。这些操作就
包括以受控的方式终止进程或立刻终止进程

信号能够中断正在运行的程序。当进程接收到一个信号时，它会执行对应的信号处理程序
（signal handler）作为响应。编译型的应用程序使用系统调用kill生成信号。在命令行（或是shell
脚本）中是通过kill命令来实现的。trap命令可以在脚本中用来处理所接收的信号

每个信号都有对应的名字以及整数值。SIGKILL (9)信号会立即终止进程。Ctrl+C会发送
信号中断任务，Ctrl+Z会发送信号将任务置入后台

Ctrl+C发送的是SIGINT信号。它和SIGKILL信号的区别在于后者不能被捕获，也不能被忽略

1.  kill -l命令可以列出所有可用的信号

```shell
$ kill -l
SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP
...
```

2. 终止进程

```shell
$ kill PROCESS_ID_LIST 
# kill命令默认发送SIGTERM信号。进程ID列表中使用空格来分隔各个进程ID
```

3. 选项-s可以指定发送给进程的信号

```shell
$ kill -s SIGNAL PID 
```

参数SIGNAL可以是信号名或编号。尽管信号的用途各种各样，但常用的其实也就是那么几个

- SIGHUP 1：对控制进程或终端的结束进行挂起检测（hangup detection）
- SIGINT 2：当按下Ctrl+C时发送该信号
- SIGKILL 9：用于强行杀死进程
- SIGTERM 15：默认用于终止进程
- SIGTSTP 20：当按下Ctrl+Z时发送该信号

4. 我们经常需要强行杀死进程，这样做的时候要小心。这种做法立刻生效，根本没有机会
   保存数据或执行通常的清理工作。应该先尝试使用SIGTERM，将SIGKILL留作最后一招

```shell
$ kill -s SIGKILL PROCESS_ID
# 或者
$ kill -9 PROCESS_ID
```

补充内容

Linux中还有其他一些可以发送信号或终止进程的命令

1. kill命令系列

```shell
# kill命令以进程ID作为参数。killall命令可以通过名字来终止进程
$ killall process_nam

# 选项-s可以指定要发送的信号。killall默认发送SIGTERM信号
$ killall -s SIGNAL process_name 

# 选项-9可以依照名字强行杀死进程
$ killall -9 process_name 

$ killall -9 gedit 

# 选项-u可以指定进程所属用户
$ killall -u USERNAME process_name 

# 如果需要在杀死进程前进行确认，可以使用killall的-I选项

# pkill命令和kill命令类似，不过默认情况下pkill接受的是进程名，而非进程ID
$ pkill process_name
$ pkill -s SIGNAL process_name 
# SIGNAL是信号编号。pkill不支持信号名，该命令的很多选项和kill一样
```

2. 捕获并响应信号

设计良好的程序在接收到SIGTERM信号时会保存好数据，然后放心地结束（shut down
cleanly）。trap命令在脚本中用来为信号分配信号处理程序。一旦使用trap将某个函数分配给一
个信号，那么当脚本运行收到该信号时，就会执行相应的函数

```shell
# 命令语法如下
trap 'signal_handler_function_name' SIGNAL_LIST 
# SIGNAL_LIST以空格分隔，它可以是信号编号或信号名
```

详见：sighandle.sh

#### 向用户终端发送消息





#### /proc文件系统





#### 收集系统信息





#### 使用cron进行调度





#### 数据库的形式及用法





#### 读写SQLite数据库





#### 读写MySQL数据库





#### 用户管理脚本





#### 图像文件的批量缩放及格式转换





#### 终端截图





#### 集中管理多个终端





