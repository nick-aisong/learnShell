让文本飞
========

| 目录                           | 主要命令 |
| ------------------------------ | -------- |
| 使用正则表达式                 |          |
| 使用grep在文件中搜索文本       |          |
| 使用cut按列切分文件            |          |
| 使用sed替换文本                |          |
| 使用awk进行高级文本处理        |          |
| 统计特定文件中的词频           |          |
| 压缩或解压缩JavaScript         |          |
| 按列合并多个文件               |          |
| 打印文件或行中的第n个单词或列  |          |
| 打印指定行或模式之间的文本     |          |
| 以逆序形式打印行               |          |
| 解析文本中的电子邮件地址和URL  |          |
| 删除文件中包含特定单词的句子   |          |
| 对目录中的所有文件进行文本替换 |          |
| 文本切片与参数操作             |          |

#### 使用正则表达式

1. 位置标记

位置标记锚点（position  marker  anchor）是标识字符串位置的正则表达式。默认情况下，正则表达式所匹配的字符可以出现在字符串中任何位置

| 正则表达式     | 描  述 |示  例|
| -------------- | ------ |---|
| ^ | 指定了匹配正则表达式的文本必须起始于字符串的首部 | ^tux能够匹配以tux起始的行 |
|$|指定了匹配正则表达式的文本必须结束于目标字符串的尾部|tux$能够匹配以tux结尾的行|

2. 标识符

标识符是正则表达式的基础组成部分。它定义了那些为了匹配正则表达式，必须存在（或不存在）的字符
| 正则表达式     | 描  述 |示  例|
| -------------- | ------ |---|
| A字符 | 正则表达式必须匹配该字符 | A能够匹配字符A |
|.|匹配任意一个字符|Hack.能够匹配Hackl和Hacki，但是不能匹配Hackl2或Hackil，它只能匹配单个字符|
|[]|匹配中括号内的任意一个字符。中括号内可以是一个字符组或字符范围|coo[kl]能够匹配cook或cool，[0-9]匹配任意单个数字|
|[^]|匹配不在中括号内的任意一个字符。中括号内可以是一个字符组或字符范围|9\[^01]能够匹配92和93，但是不匹配91和90；A\[^0-9]匹配A以及随后除数字外的任意单个字符|

3. 数量修饰符

一个标识符可以出现一次、多次或是不出现。数量修饰符定义了模式可以出现的次数
| 正则表达式     | 描  述 |示  例|
| -------------- | ------ |---|
| ? | 匹配之前的项1次或0次 | colou?r能够匹配color或colour，但是不能匹配colouur |
|+|匹配之前的项1次或多次|Rollno-9+能够匹配Rollno-99和Rollno-9，但是不能匹配Rollno-|
|*|匹配之前的项0次或多次|co*l能够匹配cl、col和coool|
|{n}|匹配之前的项n次|[0-9]{3}能够匹配任意的三位数，[0-9]{3}可以扩展为\[0-9]\[0-9]\[0-9]|
|{n,}|之前的项至少需要匹配n次|[0-9]{2,}能够匹配任意一个两位或更多位的数字|
|{n,m}|之前的项所必须匹配的最小次数和最大次数|[0-9]{2,5}能够匹配两位数到五位数之间的任意一个数字|

4. 其他

还有其他一些特殊字符可以调整正则表达式的匹配方式
| 正则表达式     | 描  述 |示  例|
| -------------- | ------ |---|
| () | 将括号中的内容视为一个整体 | ma(tri)?x能够匹配max或matrix |
|\|| 指定了一种选择结构，可以匹配\|两边的任意一项 |Oct{ 1st\| 2nd}能够匹配Oct 1st或Oct 2nd|
|\||转义字符可以转义之前介绍的特殊字符|a\\\.b能够匹配a.b，但不能匹配ajb。因为\忽略了.的特殊意义|

正则表达式的更多细节请参考：http://www.linuxforu.com/2011/04/sed-explained-part-1/

5. 补充内容

能够匹配任意单词的正则表达式：( +[a-zA-Z]+ +) 

开头的+表示需要匹配一个或多个空格。字符组[a-zA-Z]用于匹配所有的大小写字母。随后的+表示至少要匹配一个字母，多者不限。最后的+表示需要匹配一个或多个空格来终结单词

这个正则表达式无法匹配句子末尾的单词。要想匹配句尾或是逗号前的单词，需要将正则表达式改写为：

( +[a-zA-Z]+[?,.]? +) 

[?,.]?表示仅需要匹配问号、逗号或点号中的一个



IP地址：[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3} 

或者：[[:digit:]]{1,3}\\.[[:digit:]]{1,3}\\.[[:digit:]]{1,3}\\.[[:digit:]]{1,3}



工作原理  

正则表达式由复杂的状态机解析，尝试在目标文本中找出最佳匹配。文本可以是管道的输出、文件，甚至是在命令行中输入的字符串。正则表达式的实现方法不止一种，其实现引擎通常会选择最长的匹配

例如，对于字符串this is a test和正则表达式s.*s，匹配的内容是s is a tes，而非s is



补充内容

1. 处理特殊字符

正则表达式用$、^、.、*、+、{以及}等作为特殊字符。但是如果我们希望将这些字符作为普通字符使用，应该怎么做呢？来看一个正则表达式：a.txt

该正则表达式能够匹配字符a，然后是任意字符（由.负责匹配），接着是字符串txt。但是我们希望.能够匹配字面意义上的.，而非任意字符。因此需要在.之前加上一个反斜线\（这叫作“字符转义”）。这表明正则表达式希望匹配的是字面含义，而不是它所代表的特殊含义。因此，最终的正则表达式就变成了a\.txt

2. 可视化正则表达式

正则表达式不容易理解。幸好有一些将正则表达式进行可视化的工具。你可以在页面http://www.regexper.com中输入正则表达式，然后创建出一副图示来帮助你理解



#### 使用grep在文件中搜索文本    

1. 在stdin中搜索匹配特定模式的文本行

```shell
echo -e "this is a word\nnext line" | grep word 
this is a word 
```

2. 在文件中搜索匹配特定模式的文本行

```shell
grep pattern filename
this is the line containing pattern
或者
grep "pattern" filename
this is the line containing pattern 
```

3. 在多个文件中搜索匹配特定模式的文本行

```shell
grep "match_text" file1 file2 file3 ... 
```

4. 选项--color可以在输出行中着重标记出匹配到的模式。尽管该选项在命令行中的放置
   位置没有强制要求，不过惯常作为第一个选项出现

```shell
grep --color=auto word filename 
this is the line containing word 
```

5. grep命令默认使用基础正则表达式。这是先前描述的正则表达式的一个子集。选项-E可以
   使grep使用扩展正则表达式。也可以使用默认启用扩展正则表达式的egrep命令

```shell
grep -E "[a-z]+" filename
或者
egrep "[a-z]+" filename
```

6. 选项-o可以只输出匹配到的文本

```shell
echo this is a line. | egrep -o "[a-z]+\." 
line
```

7. 选项-v可以打印出不匹配match_pattern的所有行

```shell
grep -v match_pattern file  #选项-v能够反转（invert）匹配结果
```

8. 选项-c能够统计出匹配模式的文本行数

```shell
grep -c "text" filename  #需要注意的是-c只是统计匹配行的数量，并不是匹配的次数
10

echo -e "1 2 3 4\nhello\n5 6" | egrep -c "[0-9]" 
2
```

9. 要统计文件中匹配项的数量，可以使用下面的技巧

```shell
echo -e "1 2 3 4\nhello\n5 6" | egrep -o "[0-9]" | wc -l
```

10. 选项-n可以打印出匹配字符串所在行的行号

```shell
$ cat sample1.txt
gnu is not unix 
linux is fun 
bash is ary

$ cat sample2.txt
planetlinux 

$ grep linux -n sample1.txt 
2:linux is fun 
或者
$ cat sample1.txt | grep linux -n

# 如果涉及多个文件，该选项也会随输出结果打印出文件名
$ grep linux -n sample1.txt sample2.txt
sample1.txt:2:linux is fun
sample2.txt:2:planetlinux
```

11. 选项-b可以打印出匹配出现在行中的偏移。配合选项-o可以打印出匹配所在的字符或
    字节偏移

```shell
echo gnu is not unix | grep -b -o "not" 
7:not
```

12. 选项-l可以列出匹配模式所在的文件

```shell
grep -l linux sample1.txt sample2.txt
sample1.txt
sample2.txt
# 和-l效果相反的选项是-L，它会返回一个不匹配的文件列表
```

补充内容

1. 递归搜索多个文件

```shell
grep "text" . -R -n 
# grep的选项-R和-r功能一样
```

例如：

```shell
$ cd src_dir
$ grep "test_function()" . -R -n
./miscutils/test.c:16:test_function(); 

# 它等价于下列命令：
$ find . -type f | xargs grep "test_function()" 
```

2. 忽略模式中的大小写

```shell
echo hello world | grep -i "HELLO" 
hello
```

3. 使用grep匹配多个模式

```shell
# 选项-e可以指定多个匹配模式
grep -e "pattern1" -e "pattern2" 

# 上述命令会打印出匹配任意一种模式的行，每个匹配对应一行输出
echo this is a line of text | grep -o -e "this" -e "line"
this
line 

# 可以将多个模式定义在文件中。选项-f可以读取文件并使用其中的模式（一个模式一行）
grep -f pattern_filesource_filename 

例如：
$ cat pat_file
hello
cool
$ echo hello this is cool | grep -f pat_file
hello this is cool
```

4. 在grep搜索中指定或排除文件

   grep可以在搜索过程中使用通配符指定（include）或排除（exclude）某些文件

```shell
# 使用--include选项在目录中递归搜索所有的 .c和 .cpp文件
grep "main()" . -r --include *.{c,cpp} 
# 注意，some{string1,string2,string3}会被扩展成somestring1 somestring2 somestring3

# 使用选项--exclude在搜索过程中排除所有的README文件
grep "main()" . -r --exclude "README" 

# 选项--exclude-dir可以排除目录
grep main . -r -exclude-dir CVS 

# 如果需要从文件中读取排除文件列表，使用--exclude-from FILE
```

5. 使用0值字节后缀的xargs与grep

   xargs命令可以为其他命令提供命令行参数列表。当文件名作为命令行参数时，建议用0值
   字节作为文件名终结符，而非空格。因为一些文件名中会包含空格字符，一旦它被误解为终结符，
   那么单个文件名就会被视为两个（例如，New file.txt被解析成New和file.txt两个文件名）。这个问
   题可以利用0值字节后缀来避免。我们使用xargs从命令（如grep和find）中接收stdin文本。
   这些命令可以生成带有0值字节后缀的输出。为了指明输入中的文件名是以0值字节作为终结，需
   要在xargs中使用选项-0

```shell
# 创建测试文件：
echo "test" > file1
echo "cool" > file2
echo "test" > file3 

# 选项-l告诉grep只输出有匹配出现的文件名
# 选项-Z使得grep使用0值字节（\0）作为文件名的终结符
# 这两个选项通常都是配合使用的
# xargs的-0选项会使用0值字节作为输入的分隔符

grep "test" file* -lZ | xargs -0 rm 
```

6. grep的静默输出

   有时候，我们并不打算查看匹配的字符串，而只是想知道是否能够成功匹配。这可以通过设
   置grep的静默选项（-q）来实现。在静默模式中，grep命令不会输出任何内容。它仅是运行命
   令，然后根据命令执行成功与否返回退出状态。0表示匹配成功，非0表示匹配失败

详见  silent_grep.sh 

7. 打印出匹配文本之前或之后的行

   基于上下文的打印是grep的一个挺不错的特性。当grep找到了匹配模式的行时，它只会打
   印出这一行。但我们也许需要匹配行之前或之后的n行。这可以通过控制选项-B和-A来实现

```shell
# 选项-A可以打印匹配结果之后的行
$ seq 10 | grep 5 -A 3
5
6
7
8 

# 选项-B可以打印匹配结果之前的行
$ seq 10 | grep 5 -B 3
2
3
4
5 

# 选项-A和-B可以结合使用，或者也可以使用选项-C，它可以分别打印出匹配结果之前及之后的n行
$ seq 10 | grep 5 -C 3
2
3
4
5
6
7
8 

# 如果有多个匹配，那么使用--作为各部分之间的分隔
$ echo -e "a\nb\nc\na\nb\nc" | grep a -A 1
a
b
--
a
b 
```

#### 使用cut按列切分文件    

cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、
CSV文件或是由空格分隔的文件（例如标准日志文件）

cut命令能够提取指定位置或列之间的字符。你可以指定每列的分隔符。在cut的术语中，
每列被称为一个字段

1. 选项-f可以指定要提取的字段

```shell
cut -f FIELD_LIST filename 
# FIELD_LIST是需要显示的列。它由列号组成，彼此之间用逗号分隔

cut -f 2,3 filename  # 该命令将显示第2列和第3列
```

2. cut命令也能够从stdin中读取输入

   制表符是字段默认的分隔符。对于没有使用分隔符的行，会将该行照原样打印出来。cut
   的选项-s可以禁止打印出这种行。下面的例子演示了如何从使用制表符作为分隔符的文
   件中提取列

```shell
$ cat student_data.txt
No Name Mark Percent
1 Sarath 45 90
2 Alex 49 98
3 Anu 45 90 

$ cut -f1 student_data.txt
No
1
2
3 
```

3. 要想提取多个字段，就得给出由逗号分隔的多个字段编号

```shell
$ cut -f2,4 student_data.txt
Name Percent
Sarath 90
Alex 98
Anu 90 
```

4. 我们也可以用 --complement选项显示出没有被-f指定的那些字段。下面的命令会打印
   出除第3列之外的所有列

```shell
$ cut -f3 --complement student_data.txt
No Name Percent
1 Sarath 90
2 Alex 98
3 Anu 90 
```

5. 选项-d能够设置分隔符。下面的命令展示了如何使用cut处理由分号分隔的字段

```shell
$ cat delimited_data.txt
No;Name;Mark;Percent
1;Sarath;45;90
2;Alex;49;98
3;Anu;45;90

$ cut -f2 -d";" delimited_data.txt
Name
Sarath
Alex
Anu 
```

补充内容

cut命令还有其他一些选项可以指定要显示的列

指定字段的字符或字节范围

| N-   | 从第N个字节、字符或字段开始到行尾                            |
| ---- | ------------------------------------------------------------ |
| N-M  | 从第N个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段 |
| -M   | 从第1个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段 |

我们使用上面介绍的记法，结合下列选项将字段指定为某个范围内的字节、字符或字段：

- -b 表示字节
- -c 表示字符
- -f 用于定义字段

```shell
$ cat range_fields.txt
abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxyz
abcdefghijklmnopqrstuvwxy 

# 打印第2个到第5个字符
$ cut -c2-5 range_fields.txt
bcde
bcde
bcde
bcde 

# 打印前2个字符
$ cut -c -2 range_fields.txt
ab
ab
ab
ab 

# 若要用字节作为计数单位，可以将-c替换成-b

# 选项--output-delimiter可以指定输出分隔符。在显示多组数据时，该选项尤为有用：
$ cut range_fields.txt -c1-3,6-9 --output-delimiter ","
abc,fghi
abc,fghi
abc,fghi
abc,fghi
```

#### 使用sed替换文本    







#### 使用awk进行高级文本处理    







#### 统计特定文件中的词频    







#### 压缩或解压缩JavaScript    







#### 按列合并多个文件    







#### 打印文件或行中的第n个单词或列    







#### 打印指定行或模式之间的文本    







#### 以逆序形式打印行    









#### 解析文本中的电子邮件地址和URL    







#### 删除文件中包含特定单词的句子    







#### 对目录中的所有文件进行文本替换    







#### 文本切片与参数操作



